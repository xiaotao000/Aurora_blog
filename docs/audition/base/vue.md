# vue相关面试题

## 谈谈你对 `Vue` 的理解吧？

渐进式 `JavaScript` 框架、核心库加插件、动态创建用户界面（异步获取后台数据，数据展示在界面）

特点： `MVVM` 模式；代码简洁体积小，运行效率高，适合移动PC端开发；本身只关注 `UI` （和 `react` 相似），可以轻松引入 Vue 插件或其他的第三方库进行开发。

## 说一下 `Vue` 有哪些优点和特点

-   **渐进式框架**：可以在任何项目中轻易的引入；
-   **轻量级框架**：只关注视图层，是一个构建数据的视图集合，大小只有几十 `kb` ；
-   **简单易学**：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
-   **双向数据绑定**：在数据操作方面更为简单；
-   **组件化**：很大程度上实现了逻辑的封装和重用，在构建单页面应用方面有着独特的优势；
-   **视图，数据，结构分离**：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；

## `vue` 组件间传值的 `n` 种方式
**（1）`props / $emit` 适用 父子组件通信**

**（2）`ref` 适用 父子组件通信**

-   `ref`：如果在普通的 `DOM` 元素上使用，引用指向的就是 `DOM` 元素；如果用在子组件上，引用就指向组件实例

**（3）`$parent` / `$children` / `$root`：访问父 / 子实例 / 根实例**

**（4）`EventBus （$emit / $on）` 适用于 父子、隔代、兄弟组件通信**

这种方法通过一个空的 `Vue` 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

**（5）`$attrs`/`$listeners` 适用于 隔代组件通信**

-   `$attrs`：包含了父作用域中不被 `prop` 所识别 (且获取) 的特性绑定 ( `class` 和 `style` 除外 )。当一个组件没有声明任何 `prop` 时，这里会包含所有父作用域的绑定 ( `class` 和 `style` 除外 )，并且可以通过 `v-bind="$attrs"` 传入内部组件。通常配合 `inheritAttrs` 选项一起使用。
-   `$listeners`：包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件

**（6）`provide / inject` 适用于 隔代组件通信**

祖先组件中通过 `provide` 来提供变量，然后在子孙组件中通过 `inject` 来注入变量。`provide / inject API` 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

**（7）`Vuex` 适用于 父子、隔代、兄弟组件通信**

`Vuex` 是一个专为 `Vue.js` 应用程序开发的状态管理模式。每一个 `Vuex` 应用的核心就是 `store`（仓库）。`store` 基本上就是一个容器，它包含着你的应用中大部分的状态 ( `state` )。

-   `Vuex` 的状态存储是响应式的。当 `Vue` 组件从 `store` 中读取状态的时候，若 `store` 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
-   改变 `store` 中的状态的唯一途径就是显式地提交 `(commit) mutation`。这样使得我们可以方便地跟踪每一个状态的变化。

**（8）插槽**

`Vue3` 可以通过 `usesolt` 获取插槽数据。

**（9）`mitt.js` 适用于任意组件通信**

`Vue3` 中移除了 `$on`，`$off`等方法，所以 `EventBus` 不再使用，相应的替换方案就是 `mitt.js`

## `vue` 有哪些内置指令
![img](./assets/vue%E5%86%85%E7%BD%AE%E5%91%BD%E4%BB%A4.webp)

## `v-show` 和 `v-if` 有什么区别

-   **手段**：`v-if` 是动态的向 `DOM` 树内添加或者删除 `DOM` 元素；`v-show` 是通过设置 `DOM` 元素的 `display` 样式属性控制显隐；
-   **编译过程**：`v-if` 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；`v-show` 只是简单的基于 `css` 切换；
-   **编译条件**：`v-if` 是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; `v-show` 是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且 `DOM` 元素保留；
-   **性能消耗**：`v-if` 有更高的切换消耗；`v-show` 有更高的初始渲染消耗；
-   **使用场景**：`v-if` 适合运营条件不大可能改变；`v-show` 适合频繁切换。

## `vue` 首屏渲染优化有哪些

-   图片压缩/懒加载
-   禁止生成 `.map` 文件
-   路由懒加载
-   `cdn` 引入公共库
-   开启 `GZIP` 压缩

## `vue` 生命周期函数有哪些

`Vue` 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的的生命周期钩子订阅好（内部采用数组的方式存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）。

-   `beforeCreate`：是 `new Vue()` 之后触发的第一个钩子，在当前阶段 `data`、`methods`、`computed` 以及 `watch` 上的数据和方法都不能被访问。
-   `created`：在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 `updated` 函数。可以做一些初始数据的获取，在当前阶段无法与 `Dom` 进行交互，如果非要想，可以通过 `vm.$nextTick` 来访问 `Dom`。
-   `beforeMount`：发生在挂载之前，在这之前 `template` 模板已导入渲染函数编译。而当前阶段虚拟 `Dom` 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 `updated`。
-   `mounted`：在挂载完成后发生，在当前阶段，真实的 `Dom` 挂载完毕，数据完成双向绑定，可以访问到 `Dom` 节点，使用 `$refs` 属性对 `Dom` 进行操作。
-   `beforeUpdate`：发生在更新之前，也就是响应式数据发生更新，虚拟 `dom` 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。
-   `updated`：发生在更新完成之后，当前阶段组件 `Dom` 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。
-   `beforeDestroy`：发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
-   `destroyed`：发生在实例销毁之后，这个时候只剩下了 `dom` 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

## 第一次页面加载会触发哪几个钩子

`beforeCreate`，`created`，`beforeMount`，`mounted`

## `vue-router` 有几种模式

`vue-router` 有 3 种路由模式：`hash`、`history`、`abstract`：

-   **hash**: 使用 `URL hash` 值来作路由。支持所有浏览器，包括不支持 `HTML5 History Api` 的浏览器；
-   **history** : 依赖 `HTML5 History API` 和服务器配置。
-   **abstract** : 支持所有 `JavaScript` 运行环境，如 `Node.js` 服务器端。如果发现没有浏览器的 `API`，路由会自动强制进入这个模式.

## `vuex` 有哪些属性

有五种，分别

-   **State**：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
-   **Getter**：允许组件从 `Store` 中获取数据，`mapGetters` 辅助函数仅仅是将 `store` 中的 `getter` 映射到局部计算属性。
-   **Mutation**：是唯一更改 `store` 中状态的方法，且必须是同步函数。
-   **Action**：用于提交 `mutation`，而不是直接变更状态，可以包含任意异步操作。
-   **Module**：允许将单一的 `Store` 拆分为多个 `store` 且同时保存在单一的状态树中。

## 学完 `vue3` 有什么想法么？`nuxt` 什么感想

答：`vue3` 在代码编写层面，可以更好的完成结构和逻辑的复用。`nuxt` 是一个约定大于配置的框架，很多东西人家都给封装好了，按照约定去写就可以了，有利于团队协作。

## `vue2` 和 `vue3` 有什么区别

-   响应式原理
-   生命周期钩子名称
-   自定义指令钩子名称
-   新的内置组件
-   `diff` 算法
-   `Composition API`

## `watch` 和 `computed` 区别和使用场景

**对于Computed：**

-   它支持缓存，只有依赖的数据发生了变化，才会重新计算
-   不支持异步，当 `Computed` 中有异步操作时，无法监听数据的变化
-   如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用 computed
-   如果 `computed` 属性的属性值是函数，那么默认使用 `get` 方法，函数的返回值就是属性的属性值；在 `computed` 中，属性有一个 `get` 方法和一个 `set` 方法，当数据发生变化时，会调用 `set` 方法。

**对于Watch：**

-   它不支持缓存，当一个属性发生变化时，它就会触发相应的操作

-   支持异步监听

-   监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值

-   监听数据必须是 `data` 中声明的或者父组件传递过来的 `props` 中的数据，当发生变化时，会触发其他操作

-   函数有两个的参数：

    -   **immediate**：组件加载立即触发回调函数
    -   **deep**：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。

## `Vue` 实现双向数据绑定原理是什么？
Vue2.x 采用数据劫持结合发布订阅模式（PubSub 模式）的方式，通过 `Object.defineProperty` 来劫持各个属性的 `setter、getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

`Vue3.x` 放弃了 `Object.defineProperty` ，使用 `ES6` 原生的 Proxy，来解决以前使用 `Object.defineProperty` 所存在的一些问题。

## `nextTick` 的作用是什么？
作用：`vue` 更新 `DOM` 是异步更新的，数据变化，`DOM` 的更新不会马上完成，`nextTick` 的回调是在下次 `DOM` 更新循环结束之后执行的延迟回调。

## `scoped` 是如何实现样式穿透的？

**方法一**

使用 ::v-deep 操作符( >>> 的别名)

**方法二**

定义一个含有 `scoped` 属性的 `style` 标签之外，再定义一个不含有 `scoped` 属性的 `style` 标签，即在一个 vue 组件中定义一个全局的 `style` 标签，一个含有作用域的 `style` 标签此时，我们只需要将修改第三方样式的 `css` 写在第一个 `style` 中即可。


**方法三**

上面的方法一需要单独书写一个不含有 scoped 属性的 `style` 标签，可能会造成全局样式的污染。
更推荐的方式是在组件的外层 `DOM` 上添加唯一的 `class` 来区分不同组件，在书写样式时就可以正常针对针对这部分 `DOM` 书写样式。